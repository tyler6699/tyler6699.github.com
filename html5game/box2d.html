<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<script src="assets/js/Box2dWeb-2.1.a.3.min.js"></script>
<style>
canvas {
    border:1px solid #d3d3d3;
    background-color: #f1f1f1;
}
</style>
</head>
<body onload="startGame()">

<script>
var myGamePiece;
var tiles = [];
var sqr = 20;
var tileSize = 16;

for(x = 0; x < sqr; x++){
  for(y = 0; y < sqr; y++){
    xx = x * tileSize;
    yy = y * tileSize;
    if((xx < 100 || xx > 500) || (yy < 90 || yy > 500)){
      color = "#000080";
    } else {
      color = "#228B22";
    }

    var tile = new component(tileSize, tileSize, color, xx, yy, "tile");
    tiles.push(tile);
  }
}

// box2d
var WIDTH_PX=800;   //screen width in pixels
var HEIGHT_PX=600; //screen height in pixels
var SCALE=1;      //how many pixels in a meter
var WIDTH_M=WIDTH_PX/SCALE; //world width in meters. for this example, world is as large as the screen
var HEIGHT_M=HEIGHT_PX/SCALE; //world height in meters

// B2WORLD
b2Vec2		      = Box2D.Common.Math.b2Vec2;
b2BodyDef	      = Box2D.Dynamics.b2BodyDef;
b2Body		      = Box2D.Dynamics.b2Body;
b2FixtureDef	  = Box2D.Dynamics.b2FixtureDef;
b2World		      = Box2D.Dynamics.b2World;
b2PolygonShape	= Box2D.Collision.Shapes.b2PolygonShape;
b2CircleShape	  = Box2D.Collision.Shapes.b2CircleShape;
debugDraw       = Box2D.Dynamics.b2DebugDraw;

function startGame() {
    myGamePiece = new component(30, 30, "white", 115, 115);
    myGameArea.start();
}

var myGameArea = {
    canvas : document.createElement("canvas"),
    start : function() {
        this.canvas.width = 800;
        this.canvas.height = 600;
        this.context = this.canvas.getContext("2d");
        document.body.insertBefore(this.canvas, document.body.childNodes[0]);
        this.frameNo = 0;
        this.interval = setInterval(updateGameArea, 20);
        window.addEventListener('keydown', function (e) {
            e.preventDefault();
            myGameArea.keys = (myGameArea.keys || []);
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        })
        window.addEventListener('keyup', function (e) {
            myGameArea.keys[e.keyCode] = (e.type == "keydown");
        })
    },
    stop : function() {
        clearInterval(this.interval);
    },
    clear : function() {
        this.context.clearRect(0, 0, this.canvas.width, this.canvas.height);
    }
}
var b2BodyDef2	= new b2BodyDef();
var world = new b2World(new b2Vec2(0, 0),  true);
var bodyDef = new b2BodyDef();
var bxFixDef	= new b2FixtureDef();

bodyDef.type = b2Body.b2_staticBody;
bxFixDef.shape	= new b2PolygonShape();
bxFixDef.shape.SetAsBox(400, 400);
bodyDef.position.Set(10, 10);
world.CreateBody(bodyDef).CreateFixture(bxFixDef);

var debugDraw = new debugDraw();
debugDraw.SetSprite(myGameArea.canvas.getContext("2d"));
debugDraw.SetDrawScale(SCALE);
//debugDraw.SetFillAlpha(0.5);
debugDraw.SetLineThickness(1.0);
debugDraw.SetFlags(debugDraw.e_shapeBit);
world.SetDebugDraw(debugDraw);

function component(width, height, color, x, y, type) {
    this.type = type;
    this.width = width;
    this.height = height;
    this.speed = 1;
    this.angle = 0;
    this.moveAngle = 0;
    this.x = x;
    this.y = y;
    this.color = color;
    this.power = 0;

    if (type == "tile") {
      this.image = new Image();
      this.image.src = "assets/8x8/grass/grass_04_32.png";
    }

    // Render
    this.update = function() {
        ctx = myGameArea.context;
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.angle);

        if (type == "tile") {
          ctx.drawImage(this.image, this.x, this.y, this.width * 1.9, this.height * 1.9);
        } else {
          ctx.fillStyle = this.color;
          ctx.fillRect(this.width / -2, this.height / -2, this.width, this.height);
        }

        ctx.restore();
    }
    this.newPos = function() {
        this.angle += this.moveAngle * Math.PI / 180;
        this.x += (this.power * this.speed) * Math.sin(this.angle);
        this.y -= (this.power * this.speed) * Math.cos(this.angle);
    }
}

function updateGameArea() {
  world.Step(1 / 60,  3,  3);
  world.ClearForces();
  myGameArea.clear();

  for (i=0; i<tiles.length; i++) {
    tile = tiles[i];
    //tile.update();
  }

  myGamePiece.moveAngle = 0;
  if(myGamePiece.power > 0){
      myGamePiece.power -= 0.4;
  } else if(myGamePiece.power < 0){
    myGamePiece.power += 0.4;
  }
  if (myGameArea.keys && myGameArea.keys[37]) {myGamePiece.moveAngle = -12; }
  if (myGameArea.keys && myGameArea.keys[39]) {myGamePiece.moveAngle = 12; }
  if (myGameArea.keys && myGameArea.keys[38]) {myGamePiece.power = 5; }
  if (myGameArea.keys && myGameArea.keys[40]) {myGamePiece.power = -1; }
  myGamePiece.newPos();
  myGamePiece.update();

  // DEBUG
  //world.DrawDebugData();
}
</script>

<p>Make sure the gamearea has focus, and use the arrow keys to move the red square around.</p>

</body>
</html>
